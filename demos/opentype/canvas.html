<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <!-- 
      Provide a comma separated list of SMuFL glyph names.
      See: https://w3c.github.io/smufl/latest/tables/
           https://w3c.github.io/smufl/latest/tables/clefs.html
           https://w3c.github.io/smufl/latest/tables/flags.html
           https://w3c.github.io/smufl/latest/tables/beamed-groups-of-notes.html
           ...etc
      We will draw the glyphs on a canvas in three different fonts (Bravura, Gonville, Petaluma).
      Use the keyboard's arrow keys to cycle through the glyphs.
    -->
    <script src="https://cdn.jsdelivr.net/npm/wawoff2@2.0.1/build/decompress_binding.js"></script>
    <script>
      let resolveWawoff2;
      window.wawoff2IsReady = new Promise((resolve) => {
        resolveWawoff2 = resolve;
      });

      // Decompress *.woff2 files with wawoff2@2.0.1.
      window.Module = {
        onRuntimeInitialized: () => {
          resolveWawoff2(window.Module);
        },
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
    <script src="../../build/cjs/vexflow-debug.js"></script>
    <style>
      body {
        font-family: sans-serif;
        margin: 20px 30px;
        background-color: #191919;
        color: #ddd;
      }

      a {
        color: #9af;
      }

      canvas {
        border: 1px solid black;
        background-color: #ddd;
        display: block;
        margin-bottom: 20px;
      }

      div#glyphs {
        display: flex;
        justify-content: left;
        align-items: center;
        font-family: monospace;
        font-size: 1.3em;
        width: 100%;
        padding: 10px 20px;
        box-sizing: border-box;
        border: 1px solid #ccc;
        min-height: 50px;
        background-color: #ccc;
        color: #000;
      }

      div#glyphs span.selected {
        color: #000;
        text-decoration: underline;
      }

      div#glyphs span.not-selected {
        color: #888;
      }
    </style>
  </head>
  <body>
    <p>
      This page demonstrates how we can use <a href="https://opentype.js.org/">opentype.js</a> to draw a glyph onto a
      <code>&lt;canvas&gt;</code>. We load Bravura and Gonville and Petaluma. Enter a comma-separated list of SMuFL
      glyph names below. Cycle through the glyphs with the keyboard arrow keys.
    </p>
    <div id="glyphs" contenteditable="true"></div>
    <br /><br />
    <canvas id="bravura-output" width="1000" height="400"></canvas>
    <canvas id="gonville-output" width="1000" height="400"></canvas>
    <canvas id="petaluma-output" width="1000" height="400"></canvas>
    <script type="module">
      let currentGlyphIndex = 0;
      let glyphNames = [];
      const DEFAULT_GLYPH_NAMES = [
        'augmentationDot',
        'articStaccatoAbove',
        'articStaccatoBelow',
        'noteheadDiamondBlack',
        'keyboardPedalDot',
        'accdnCombDot',
        /*
        'gClef',
        'fClef',
        'noteheadWhole',
        'flag8thUp',
        */
      ];

      const originOffset = [200, 200];

      const fontNames = ['Bravura', 'Gonville', 'Petaluma'];

      const fonts = {};

      function loadFont(fontName) {
        const fontURL = VexFlow.Font.getURLForFont(fontName);
        return fetch(fontURL)
          .then((response) => response.arrayBuffer())
          .then((compressedArrayBuffer) => {
            const decompressedUint8Array = Module.decompress(compressedArrayBuffer);
            const decompressedArrayBuffer = decompressedUint8Array.buffer.slice(
              decompressedUint8Array.byteOffset,
              decompressedUint8Array.byteLength + decompressedUint8Array.byteOffset
            );
            const font = opentype.parse(decompressedArrayBuffer);
            console.log(font.names.fullName.en, 'loaded with', font.numGlyphs, 'glyphs.');
            fonts[fontName] = font;

            const canvas = document.getElementById(fontName.toLowerCase() + '-output');
            const ctx = canvas.getContext('2d');

            doubleCanvasIfHighDPI(canvas, ctx);
            return ctx;
          });
      }

      wawoff2IsReady.then((wawoff2) => {
        loadFont('Bravura').then((ctx) => {
          updateGlyphCanvases();
        });
        loadFont('Petaluma').then((ctx) => {
          updateGlyphCanvases();
        });
        loadFont('Gonville').then((ctx) => {
          updateGlyphCanvases();
        });
      });

      function draw(glyph, ctx, fontName, size = 72) {
        const x = originOffset[0];
        const y = originOffset[1];
        glyph.draw(ctx, x, y, size);
        glyph.drawPoints(ctx, x, y, size);
        glyph.drawMetrics(ctx, x, y, size);
        drawOrigin(ctx);
      }

      // Draw the origin as a cross.
      function drawOrigin(ctx) {
        const r = 10;
        ctx.globalAlpha = 1;
        ctx.save();
        ctx.translate(originOffset[0], originOffset[1]);
        ctx.strokeStyle = '#ff6347';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-r, 0);
        ctx.lineTo(r, 0);
        ctx.moveTo(0, -r);
        ctx.lineTo(0, r);
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, r, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.restore();
      }

      function doubleCanvasIfHighDPI(canvas, ctx) {
        const ratio = window.devicePixelRatio;
        console.log(ratio);
        if (ratio > 1) {
          const canvasWidth = canvas.width;
          const canvasHeight = canvas.height;

          canvas.width = canvasWidth * ratio;
          canvas.height = canvasHeight * ratio;
          canvas.style.width = canvasWidth + 'px';
          canvas.style.height = canvasHeight + 'px';

          ctx.scale(ratio, ratio);
        }
      }

      function setupKeyboardHandlers() {
        document.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowLeft') {
            currentGlyphIndex--;
          } else if (e.key === 'ArrowRight') {
            currentGlyphIndex++;
          }
          if (currentGlyphIndex < 0) {
            currentGlyphIndex = 0;
          } else if (currentGlyphIndex >= glyphNames.length) {
            currentGlyphIndex = glyphNames.length - 1;
          }
          updateGlyphsInputTextBox();
          updateGlyphCanvases();
        });
      }

      function saveGlyphNames() {
        localStorage.setItem('glyphNames', glyphNames.join(','));
      }

      function loadGlyphNames() {
        const names = localStorage.getItem('glyphNames');
        if (names !== null && names.length > 0) {
          names = names.replace(/\s/g, '');
          glyphNames = names.split(',');
        } else {
          glyphNames = DEFAULT_GLYPH_NAMES;
        }
        updateGlyphsInputTextBox();
      }

      function updateGlyphsInputTextBox() {
        const items = glyphNames.map((item, index) => {
          if (index === currentGlyphIndex) {
            return '<span class="selected">' + item + '</span>';
          } else {
            return '<span class="not-selected">' + item + '</span>';
          }
        });

        document.getElementById('glyphs').innerHTML = items.join(',&nbsp;');
      }

      function updateGlyphCanvases() {
        // Make sure all fonts are loaded.
        const loadedFonts = Object.keys(fonts);
        if (loadedFonts.length < fontNames.length) {
          console.log('Not all fonts are loaded yet.');
          return;
        }

        const glyph = VexFlow.Glyphs[glyphNames[currentGlyphIndex]];
        if (!glyph) {
          console.log('Unknown glyph name: ' + glyphNames[currentGlyphIndex]);
          return;
        }

        // Find the bounding box of the glyph in all fonts.
        // Keep the largest bounding box.
        let heightOfTallestGlyph = 0;
        for (let fontName of fontNames) {
          const font = fonts[fontName];
          const glyphObject = font.charToGlyph(glyph);
          const boundingBox = glyphObject.getBoundingBox();
          const height = boundingBox.y2 - boundingBox.y1;
          console.log(height);
          if (height > heightOfTallestGlyph) {
            heightOfTallestGlyph = height;
          }
        }

        // Fit the glyphs into 300 vertical pixels.
        // 300px = 100 units @ 3000 font size
        const fontSize = (300 / heightOfTallestGlyph) * 1000;

        // Draw the glyph in all fonts.
        for (let fontName of fontNames) {
          const font = fonts[fontName];
          const canvas = document.getElementById(fontName.toLowerCase() + '-output');
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Sorry for the confusing naming here.
          // The `glyph` variable is actually a single character.
          // We convert it to an opentype.js Glyph object.
          const glyphObject = font.charToGlyph(glyph);
          draw(glyphObject, ctx, fontName, fontSize);
        }
      }

      loadGlyphNames();
      setupKeyboardHandlers();
    </script>
  </body>
</html>
